###############################################################################
# Functions for AIX
# -jyxu- xujinyu@cn.ibm.com

#------------------------------------------------------------------------------
# Find the file to edit if in $PATH or in the current dir
vip () {
  ITEM=$1
  [ -z "$ITEM" -o -d "$ITEM" ] && {
    echo "usage: vip <filename>"
    return
  }

  FOUND=$(which $ITEM 2>/dev/null)
  [ "$FOUND" ] && /usr/bin/vi $FOUND || echo "Unable to locate \"$ITEM\""
  unset $FOUND; }

#------------------------------------------------------------------------------
# Find file
fit () { find /src /opt /usr /home -name ${1:?"Filename required!"} -ls; }

#------------------------------------------------------------------------------
# psf: Displays matches found in ps -ef
#      Excludes self called processes (pid)
#      Calling with no option runs ps -ef
psf () {
    #If no command line items given:
    [ "$1" ] || /bin/ps -ef | /bin/grep -v $$

    #If one or more command line items:
    for CLI do
       /bin/ps -ef | /bin/grep $CLI | /bin/grep -v $$
       shift 1
    done; }

#------------------------------------------------------------------------------
# findbigger: find FILES Bigger than certain blocks on . 
findbigger () { find . -xdev -size +"$1" -ls | sort -r -n -k7; }

#------------------------------------------------------------------------------
# dnswp: Search wikipedia through DNS
dnswp () { dig +short txt "$1".wp.dg.cx; }

#------------------------------------------------------------------------------
# histstat: Command history Stat
histstat () { history | awk '{a[$2]++}END{for(i in a){print a[i] "\t" i}}' | sort -rn | head; }

#------------------------------------------------------------------------------
# WWPN colon and de-colon
colonfy () { print $1 | sed 's/../:&/g' | cut -c2-; }
decolonfy () { print $1 | sed 's/://g'; }
colon () { sed 's/../:&/g' | cut -c2-; }
decolon () { sed 's/://g'; }

#------------------------------------------------------------------------------
# List HBA: List HBA info
lshba () { lsdev -F "name status physloc" | awk '
BEGIN {
    # Header
    print "name\tstatus\t\tphyslot\t\t\t\tWWPN\t\t\tPart #\tCCIN\tColoned WWPN";
}

$1 ~ /^fcs.+/ {
    # Name, Status, Physlot
    printf "%s\t%s\t%s\t",$1,$2,$3;
    cmd = "lscfg -vl "$1;
    while ((cmd | getline) > 0){
        FS=".";
        if (NF==18||NF==6){
            # Part Number, CCIN
            s = s"\t"$NF;
        }
        if (NF==14){
            # WWPN
            printf "%s", $NF;
            # Colonfy
            for (i=1; i<16; i=i+2){
                str = sprintf("%s:%s", str, substr($NF, i, 2))
            };
            printf("%s\t%s\n", s, substr(str, 2));
            s=str=""
        }
    }
    close(cmd);
    FS=" ";
}
'; }


#------------------------------------------------------------------------------
# mdt file sorter for io, with powerpath replacements
# Usage: mdtsort mdt.io > mdt.power
mdtsort () { awk '
NF == 1 {
    # Device
    # The "default" line.
    if ($0 == "default:") {
        dev = "default";
        power[dev] = "none";
        type[dev] = "default";
        seq[dev] = "0";
        subseq[dev] = "";
        head[dev] = "default:";
        next;
    }
    
    # Device name, trim "r" and ":".
    dev = substr($0, 2, length($0)-2);

    # Get powerpath device replacements: rhdisk => rhdiskpower.
    cmd = "powermt display dev="dev" 2>&1";
    cmd | getline s; match(s, "=");
    if (RLENGTH == 1) {
        power[dev] = dev = substr(s,RSTART+RLENGTH);
    }
    else {
        power[dev] = "none";
    }
     
    close(cmd);
  
    # Extract device type, name, sequence, subsequence ("hdisk XX :").
    match (dev, "[0-9]+")
    type[dev] = substr(dev,1,RSTART-1);
    seq[dev] = substr(dev,RSTART,RLENGTH);
    subseq[dev] = substr(dev,RSTART+RLENGTH);
  
    # De-trim
    head[dev] = "r"dev":";
    # Initialize Spec
    spec[dev] = ""
} 
  
NF > 1 {
    # All the parameters, using "|" for a tmp delimiter over newlines.
    spec[dev] = sprintf("%s|%s", spec[dev], $0);
} 
  
END {
    # Output.
    for (d in head) {
        # Default
        if (d == "default") {
            print type[d], power[d], seq[d], subseq[d], head[d], spec[d], "|";
        }
        # Raw IOs
        if (head[d] ~ /^rhd/) {
            print type[d], power[d], seq[d], subseq[d], head[d], spec[d], "|";
        }
        # FileSys IOs
        else if (head[d] ~ /^rjfs/) {
            print type[d], power[d], seq[d], subseq[d], head[d], spec[d], "|";
        }
        # Out Of Scope
        else {
            ;
        }
    }
} 
# sort the result, tailor output, and get back delimiter
' $1 | sort -k 1,1 -k 3,3n -k 4,4n | cut -d" " -f5- | tr '|' '\n'; }

#------------------------------------------------------------------------------
# jy_rmvgs: remove all vg the above function created
jy_rmvgs () {
   mount | awk '/dev\/jfs/ {system("umount "$2)}';
   lspv | awk '!/rootvg/ && /active/ {system("varyoffvg "$3)}';
   lsvg | awk '!/rootvg/ {system("exportvg "$1)}';
   lspv | awk '!/active/ && $2 != "none" {system("chdev -l "$1" -a pv=clear")}'
   ls -1 / | awk '/jfs_|jfs2_/{system("rm -r /"$1)}'; }

#------------------------------------------------------------------------------
# jy_mkvgs: Create jfs and jfs2 VGs in AIX
# Issue: 
#     * No built-in sorting in NAWK and I didn't implement or use external
#       sort. Since we are doing system calls not just outputs.
#       Expect stupid lv serials!
#
# To Reverse the effect:
#   mount | awk '/dev\/jfs/ {system("umount "$2)}'
#   lspv | awk '!/rootvg/ && /active/ {system("varyoffvg "$3)}'
#   lsvg | awk '!/rootvg/ {system("exportvg "$1)}'
#   lspv | awk '!/active/ && $2 != "none" {system("chdev -l "$1" -a pv=clear")}'
#
jy_mkvgs () { lsdev -Cc disk | awk '
BEGIN {
    # Max PP size, VG capacity, device string length, and PP number in LVs
    MAX_PP_SIZE=8; MAX_VG_CAP=512; MAX_DEV_TYPE=6; LV_PP_NUM=20;
}
# Ignore hdiskpower and SAS
/hdiskpower/ { next; }
/SAS/ { next; }
$2 != "Available" { next; }

{
    # Ignore those with PVIDs
    if (!system("lspv "$1" 2>&1 | grep -q IDENTIFIER > /dev/null"))
    next;
}

# Filter EMC, test powerpath
/EMC/ {
    # Calculate PP Size
    dev_ppsize = getppsize($1);
    dev_lunsize = getlunsize($1);
    # Do PowerPath path lookup
    cmd = "powermt display dev="$1" 2>&1";
    cmd | getline s; match(s, "="); 
    if (RLENGTH == 1) {
        powerdisk = substr(s,RSTART+RLENGTH);
    }
    close(cmd);
    
    dev = justify(powerdisk)
    lun[dev] = powerdisk
    vg[dev] = "vg_"dev;
    ppsize[dev] = dev_ppsize;
    lunsize[dev] = dev_lunsize;
    next;
}
# Others
{
    # Get justified name like hdisk001
    dev = justify($1);
    lun[dev] = $1;
    vg[dev] = "vg_"dev;
    lunsize[dev] = getlunsize(lun[dev]);
    ppsize[dev] = getppsize(lun[dev]);
}

END {
    for (d in lun){
        # Commands execution
        system("mkvg -s "ppsize[d]" -f -y "vg[d]" "lun[d]);
        system("mklv -y jfs_"d" -t jfs "vg[d]" "LV_PP_NUM);
        system("mklv -y jfs2_"d" -t jfs2 "vg[d]" "LV_PP_NUM);
        system("crfs -v jfs -d jfs_"d" -m /jfs_"d" -u testgroup -A no");
        system("crfs -v jfs2 -d jfs2_"d" -m /jfs2_"d" -u testgroup -A no");
        system("varyonvg "vg[d]);
        system("mount /jfs_"d);
        system("mount /jfs2_"d);
        system("lsvg -l "vg[d]);
        print "-------------------- The Magical Seperator ---------------------"
    }
}

# Calculate PP Size, default min to MAX_PP_SIZE
function getppsize ( device ) {
    cmd = "bootinfo -P 0 -s "device;
    cmd | getline maxppsize;
    close(cmd);
    if (maxppsize < MAX_PP_SIZE) {
        return maxppsize;
    }
    else {
        return MAX_PP_SIZE;
    }
}

# Calculate lun Size, default max to MAX_VG_CAP
function getlunsize ( device ) {
    cmd = "bootinfo -s "device;
    cmd | getline maxlunsize;
    close(cmd);

    if (maxlunsize < MAX_VG_CAP) {
        return maxlunsize - maxlunsize % 32;
    }
    else {
        return MAX_VG_CAP;
    }
}

# Get justified name like hdisk001
function justify ( str ) {
    match (str, "[0-9]+")
    type = substr(str,1,RSTART-1);
    # Shorten it
    type = substr(type,1,MAX_DEV_TYPE);
    seq = substr(str,RSTART,RLENGTH);
    return sprintf("%s%03d", type, seq);
}
'; }


#------------------------------------------------------------------------------
# calc: in awk
calc () { awk "BEGIN{ print $* }"; }

#------------------------------------------------------------------------------
# List fcscsi device and children
#lsfcs() {lsdev -Cc adapter | awk '/fcs/ {system("lsdev -C | grep "$3"\n")}'; }
lsfcs () { lsdev -Cc adapter | awk '/fcs/ {printf("\n");  system("lsdev -C | grep "$3"")}' | awk '{sub(/^hd/, "\thd")};1'; }

#------------------------------------------------------------------------------
# List disk size
lsdisksize () { lsdev -Cc disk | awk '{printf $0"\t"; system("bootinfo -s "$1)}'; }

#------------------------------------------------------------------------------
# lspath watcher
mlspath () { while true; do clear; echo 'Output of lspath'; echo '-----------------'; lspath | sort +2; sleep ${1:=5}; done; }

#------------------------------------------------------------------------------
# Get WWPN of fcsX
wwpn () { lscfg -vpl $1 | grep Address | sed 's/^.*\.//g'; }

#------------------------------------------------------------------------------
# Coloned WWPN
cwwpn () { lscfg -vpl $1 | grep Address | sed 's/^.*\.//g' | sed -e :it -e 's/\(.*[0-9A-Za-z]\)\([0-9A-Za-z]\{2\}\)/\1:\2/;tit'; }

#------------------------------------------------------------------------------
# Delete defined disk
deldefdisk () { lsdev -Cc disk | awk '/Defined/ {system("rmdev -Rdl "$1)}'; }

#------------------------------------------------------------------------------
# Delete All disk expt. active ones, like rootvg
delalldisk () { lspv | awk '!/active/ {system("rmdev -Rdl "$1)}'; }

#------------------------------------------------------------------------------
# Clear PVID
pvidclr () { lspv | awk '$4 != "active" && $2 != "none" {system("chdev -l "$1" -a pv=clear")}'; }

#------------------------------------------------------------------------------
# which hdiskpower is using this hdisk, or vice versa
disk2power () { powermt display dev=$1 2>&1 | sed -n '/^Ps/{s/.*=//;p;}'; }
power2disk () { powermt display dev=$1 | grep 'hdisk[^p]'; }

#------------------------------------------------------------------------------
# Check reserve/release options
chkreserve () { lsdev -Cc disk | awk '$4 ~ /HP|EMC|Hitachi|PowerPath/ { printf($1"\t"); system("lsattr -El "$1" -a reserve_policy") }'; }

#------------------------------------------------------------------------------
# Set all LUN to no_reserve
chgnoreserve () { lsdev -Cc disk | awk '$4 ~ /HP|EMC|Hitachi|PowerPath/ { system("chdev -l "$1" -a reserve_policy=no_reserve") }'; }


###############################################################################
# Personal Functions

#------------------------------------------------------------------------------
# Get Weather forcast from BBC
ausweather () { wget -q -O - http://newsrss.bbc.co.uk/weather/forecast/388/Next3DaysRSS.xml | awk -F'</*title>' '!a[$2]++&&NF!=1 {gsub("&#xB0;","",$2); print $2}'; }
shweather () { wget -q -O - http://newsrss.bbc.co.uk/weather/forecast/1713/Next3DaysRSS.xml | awk -F'</*title>' '!a[$2]++&&NF!=1 {gsub("&#xB0;","",$2); print $2}'; }

###############################################################################
# find wwpn in Brocade/Cisco Fabric Switch
bfind () { ssh brocade "nodefind $1"; }
cfind () { ssh cisco "show fcns database detail | grep -i -B 3 -A 15 $1"; }

#------------------------------------------------------------------------------
## ssh-copy-id to restricted shell
ssh_copy_id_restrict () {
    scp $1:.ssh/authorized_keys2 ~/.ssh/tmp_key_$1
    cat ~/.ssh/id_rsa.pub >> ~/.ssh/tmp_key_$1
    scp ~/.ssh/tmp_key_$1 $1:.ssh/authorized_keys2; }

#------------------------------------------------------------------------------
# displayTZOffset calculates the timezone offset from GMT for the current user
displayTZOffset () {
	awk 'BEGIN{
		"date +\"%H %M\"" | getline localHr localMin;
		"TZ=GMT date +\"%H %M\"" | getline gmtHr gmtMin;
	
		localTime = (localHr * 60) + localMin;
		gmtTime = (gmtHr * 60) + gmtMin;
		timeDiff = localTime - gmtTime;
		if(timeDiff > 720)
			timeDiff = 1440 - timeDiff
		else if(timeDiff < -720)
			timeDiff = -1 * (1440 + timeDiff)
		if(timeDiff < 0)
			minus = true;
		diffHr = int(timeDiff / 60);
		diffMin = timeDiff - (diffHr * 60);
		diffHr = (diffHr > 0)? diffHr : -diffHr;
		diffMin = (diffMin > 0) ? diffMin : -diffMin;
		if(minus){
			printf("%02d:%02d\n", diffHr, diffMin);
		}else{
			printf("-%02d:%02d\n", diffHr, diffMin);
		}
	}' </dev/null; }

#------------------------------------------------------------------------------
# Displays ISO8601 Date
displayISO8601Date () {
	tzOffset=`displayTZOffset`
	echo `date +%Y-%m-%dT%H:%M:%S`$tzOffset; }

#-----------------------------------------------------------------------------
# console clock
# A clock in your up-right console
cclock () { while true; do echo -ne "\e[s\e[0;$((COLUMNS-27))H$(date)\e[u"; sleep 1; done &; }



###############################################################################
# Functions for AIX
# -jyxu- xujinyu@cn.ibm.com

#------------------------------------------------------------------------------
# Find the file to edit if in $PATH or in the current dir
vip () {
  ITEM=$1
  [ -z "$ITEM" -o -d "$ITEM" ] && {
    echo "usage: vip <filename>"
    return
  }

  FOUND=$(which $ITEM 2>/dev/null)
  [ "$FOUND" ] && /usr/bin/vi $FOUND || echo "Unable to locate \"$ITEM\""
  unset $FOUND
}

#------------------------------------------------------------------------------
# Find file
fit () { find /src /opt /usr /home -name ${1:?"Filename required!"} -ls; }

#------------------------------------------------------------------------------
# psf: Displays matches found in ps -ef
#      Excludes self called processes (pid)
#      Calling with no option runs ps -ef
psf () {
    #If no command line items given:
    [ "$1" ] || /bin/ps -ef | /bin/grep -v $$

    #If one or more command line items:
    for CLI do
       /bin/ps -ef | /bin/grep $CLI | /bin/grep -v $$
       shift 1
    done
}

#------------------------------------------------------------------------------
# findbigger: find FILES Bigger than certain blocks on . 
findbigger () { find . -xdev -size +"$1" -ls | sort -r -n -k7; }

#------------------------------------------------------------------------------
# dnswp: Search wikipedia through DNS
dnswp () { dig +short txt "$1".wp.dg.cx; }

#------------------------------------------------------------------------------
# histstat: Command history Stat
histstat () { history 100 | awk '{a[$2]++}END{for(i in a){print a[i] "\t" i}}' | sort -rn | head; }

#------------------------------------------------------------------------------
# WWPN colonfy
colon () { sed -e :it -e 's/\(.*[0-9A-Za-z]\)\([0-9A-Za-z]\{2\}\)/\1:\2/;tit'; }
decolon () { sed 's/://g'; }

#------------------------------------------------------------------------------
# List HBA: List HBA info
lshba () { lsdev -F "name status physloc" | awk '
BEGIN {
    # Header
    print "name\tstatus\t\tphyslot\t\t\t\tWWPN\t\t\tPart #\tCCIN\tColoned WWPN";
}

$1 ~ /^fcs.+/ {
    # Name, Status, Physlot
    printf "%s\t%s\t%s\t",$1,$2,$3;
    cmd = "lscfg -vl "$1;
    while ((cmd | getline) > 0){
        FS=".";
        if (NF==18||NF==6){
            # Part Number, CCIN
            s = s"\t"$NF;
        }
        if (NF==14){
            # WWPN
            printf "%s", $NF;
            # Colonfy
            for (i=1; i<16; i=i+2){
                str = sprintf("%s:%s", str, substr($NF, i, 2))
            };
            printf("%s\t%s\n", s, substr(str, 2));
            s=str=""
        }
    }
    close(cmd);
    FS=" ";
}
'; }


#------------------------------------------------------------------------------
# mdt file sorter for io, with powerpath replacements
# Usage: mdtsort mdt.io > mdt.power
mdtsort () { awk '
NF == 1 {
    # Device
    # The "default" line.
    if ($0 == "default:") {
        dev = "default";
        power[dev] = "none";
        type[dev] = "default";
        seq[dev] = "0";
        subseq[dev] = "";
        head[dev] = "default:";
        next;
    }

    # Device name, trim "r" and ":".
    dev = substr($0, 2, length($0)-2);

    # Get powerpath device replacements: rhdisk => rhdiskpower.
    cmd = "powermt display dev="dev" 2>&1"; 
    cmd | getline s; match(s, "="); 
    if (RLENGTH == 1) {
        power[dev] = dev = substr(s,RSTART+RLENGTH);
    }
    else {
        power[dev] = "none";
    }
    
    close(cmd);
    
    # Extract device type, name, sequence, subsequence ("hdisk XX :").
    match (dev, "[0-9]+")
    type[dev] = substr(dev,1,RSTART-1);
    seq[dev] = substr(dev,RSTART,RLENGTH);
    subseq[dev] = substr(dev,RSTART+RLENGTH);
    
    # De-trim
    head[dev] = "r"dev":";
    
}

NF > 1 { 
    # All the parameters, using "|" for a tmp delimiter over newlines.
    spec[dev] = sprintf("%s|%s", spec[dev], $0); 
}

END {
    # Output.
    for (d in head) print type[d], power[d], seq[d], subseq[d], head[d], spec[d], "|";
}
# sort the result, tailor output, and get back delimiter
' $1 | sort -k 1,1 -k 3,3n -k 4,4n | cut -d" " -f5- | tr '|' '\n'; }

#------------------------------------------------------------------------------
# jy_rmvgs: remove all vg the above function created
jy_rmvgs () {
   mount | awk '/dev\/jfs/ {system("umount "$2)}';
   lspv | awk '!/rootvg/ && /active/ {system("varyoffvg "$3)}';
   lsvg | awk '!/rootvg/ {system("exportvg "$1)}';
   lspv | awk '!/active/ && $2 != "none" {system("chdev -l "$1" -a pv=clear")}'; }

#------------------------------------------------------------------------------
# jy_mkvgs: Create jfs and jfs2 VGs in AIX
# Issue: 
#     * No built-in sorting in NAWK and I didn't implement or use external
#       sort. Since we are doing system calls not just outputs.
#       Expect stupid lv serials!
#
# To Reverse the effect:
#   mount | awk '/dev\/jfs/ {system("umount "$2)}'
#   lspv | awk '!/rootvg/ && /active/ {system("varyoffvg "$3)}'
#   lsvg | awk '!/rootvg/ {system("exportvg "$1)}'
#   lspv | awk '!/active/ && $2 != "none" {system("chdev -l "$1" -a pv=clear")}'
#
jy_mkvgs () { lsdev -Cc disk | awk '
BEGIN {
    # Max PP size, VG capacity, device string length, and PP number in LVs
    MAX_PP_SIZE=8; MAX_VG_CAP=512; MAX_DEV_TYPE=6; LV_PP_NUM=20;
}
# Ignore hdiskpower and SAS
/hdiskpower/ { next; }
/SAS/ { next; }
$2 != "Available" { next; }

{
    # Ignore those with PVIDs
    if (!system("lspv "$1" 2>&1 | grep -q IDENTIFIER > /dev/null"))
    next;
}

# Filter EMC, test powerpath
/EMC/ {
    # Calculate PP Size
    dev_ppsize = getppsize($1);
    dev_lunsize = getlunsize($1);
    # Do PowerPath path lookup
    cmd = "powermt display dev="$1" 2>&1";
    cmd | getline s; match(s, "="); 
    if (RLENGTH == 1) {
        powerdisk = substr(s,RSTART+RLENGTH);
    }
    close(cmd);
    
    dev = justify(powerdisk)
    lun[dev] = powerdisk
    vg[dev] = "vg_"dev;
    ppsize[dev] = dev_ppsize;
    lunsize[dev] = dev_lunsize;
    next;
}
# Others
{
    # Get justified name like hdisk001
    dev = justify($1);
    lun[dev] = $1;
    vg[dev] = "vg_"dev;
    lunsize[dev] = getlunsize(lun[dev]);
    ppsize[dev] = getppsize(lun[dev]);
}

END {
    for (d in lun){
        # Commands execution
        system("mkvg -s "ppsize[d]" -f -y "vg[d]" "lun[d]);
        system("mklv -y jfs_"d" -t jfs "vg[d]" "LV_PP_NUM);
        system("mklv -y jfs2_"d" -t jfs2 "vg[d]" "LV_PP_NUM);
        system("crfs -v jfs -d jfs_"d" -m /jfs_"d" -u testgroup -A no");
        system("crfs -v jfs2 -d jfs2_"d" -m /jfs2_"d" -u testgroup -A no");
        system("varyonvg "vg[d]);
        system("mount /jfs_"d);
        system("mount /jfs2_"d);
        system("lsvg -l "vg[d]);
        print "-------------------- The Magical Seperator ---------------------"
    }
}

# Calculate PP Size, default min to MAX_PP_SIZE
function getppsize ( device ) {
    cmd = "bootinfo -P 0 -s "device;
    cmd | getline maxppsize;
    close(cmd);
    if (maxppsize < MAX_PP_SIZE) {
        return maxppsize;
    }
    else {
        return MAX_PP_SIZE;
    }
}

# Calculate lun Size, default max to MAX_VG_CAP
function getlunsize ( device ) {
    cmd = "bootinfo -s "device;
    cmd | getline maxlunsize;
    close(cmd);

    if (maxlunsize < MAX_VG_CAP) {
        return maxlunsize - maxlunsize % 32;
    }
    else {
        return MAX_VG_CAP;
    }
}

# Get justified name like hdisk001
function justify ( str ) {
    match (str, "[0-9]+")
    type = substr(str,1,RSTART-1);
    # Shorten it
    type = substr(type,1,MAX_DEV_TYPE);
    seq = substr(str,RSTART,RLENGTH);
    return sprintf("%s%03d", type, seq);
}
' ; }


#------------------------------------------------------------------------------
# calc: in awk
calc () { awk "BEGIN{ print $* }" ; }

#------------------------------------------------------------------------------
# List fcscsi device and children
#lsfcs() {lsdev -Cc adapter | awk '/fcs/ {system("lsdev -C | grep "$3"\n")}' ; }
lsfcs () { lsdev -Cc adapter | awk '/fcs/ {printf("\n");  system("lsdev -C | grep "$3"")}' | awk '{sub(/^hd/, "\thd")};1'; }

#------------------------------------------------------------------------------
# lspath watcher
mlspath () { while true; do clear; echo 'Output of lspath'; echo '-----------------'; lspath | sort +2; sleep ${1:=5}; done; }

#------------------------------------------------------------------------------
# Get WWPN of fcsX
wwpn () { lscfg -vpl $1 | grep Address | sed 's/^.*\.//g'; }

#------------------------------------------------------------------------------
# Coloned WWPN
cwwpn () { lscfg -vpl $1 | grep Address | sed 's/^.*\.//g' | sed -e :it -e 's/\(.*[0-9A-Za-z]\)\([0-9A-Za-z]\{2\}\)/\1:\2/;tit'; }

#------------------------------------------------------------------------------
# Delete defined disk
deldefdisk () { lsdev -Cc disk | awk '/Defined/ {system("rmdev -Rdl "$1)}'; }

#------------------------------------------------------------------------------
# Delete All disk expt. active ones, like rootvg
delalldisk () { lspv | awk '!/active/ {system("rmdev -Rdl "$2)}'; }

#------------------------------------------------------------------------------
# Clear PVID
pvidclr () { lspv | awk '!/active/ {system("chdev -l "$1" -a pv=clear")}'; }

#------------------------------------------------------------------------------
# which hdiskpower is using this hdisk, or vice versa
disk2power () { powermt display dev=$1 2>&1 | sed -n '/^Ps/{s/.*=//;p;}'; }
power2disk () { powermt display dev=$2 | grep 'hdisk[^p]'; }

###############################################################################
# Personal Functions

#------------------------------------------------------------------------------
# Get Weather forcast from BBC
ausweather () { wget -q -O - http://newsrss.bbc.co.uk/weather/forecast/388/Next3DaysRSS.xml | awk -F'</*title>' '!a[$2]++&&NF!=1 {gsub("&#xB0;","",$2); print $2}'; }
shweather () { wget -q -O - http://newsrss.bbc.co.uk/weather/forecast/1713/Next3DaysRSS.xml | awk -F'</*title>' '!a[$2]++&&NF!=1 {gsub("&#xB0;","",$2); print $2}'; }

#------------------------------------------------------------------------------
# Get odm: odmget default hp
odmget () { scp -r xujinyu@9.3.118.78:/cygdrive/c/pub/jyxu/odm/$1.$2 .; }

#------------------------------------------------------------------------------
# Put file to 78
to78 () { scp $1 xujinyu@9.3.118.78:/cygdrive/c/pub/jyxu/buffer/$1; }

# find wwpn in Brocade/Cisco Fabric Switch
bfind () { ssh brocade "nodefind $1"; }
cfind () { ssh cisco "show fcns database detail | grep -i -B 3 -A 15 $1"; }

